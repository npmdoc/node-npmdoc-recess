<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://twitter.github.com/recess"

    >recess (v1.1.9)</a>
</h1>
<h4>A simple, attractive code quality tool for CSS built on top of LESS</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.recess">module recess</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.recess">
            function <span class="apidocSignatureSpan"></span>recess
            <span class="apidocSignatureSpan">(paths, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor">
            function <span class="apidocSignatureSpan">recess.</span>Constructor
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.docs">
            function <span class="apidocSignatureSpan">recess.</span>docs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.</span>Constructor.RULES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.</span>Constructor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.</span>DEFAULTS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recess.Constructor">module recess.Constructor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.Constructor">
            function <span class="apidocSignatureSpan">recess.</span>Constructor
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.Constructor.</span>COMPILERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.Constructor.</span>DEFAULTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.Constructor.</span>RULES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recess.Constructor.RULES">module recess.Constructor.RULES</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.inlineImages">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>inlineImages
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noIDs">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noIDs
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noJSPrefix">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noJSPrefix
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noOverqualifying">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noOverqualifying
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noUnderscores">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noUnderscores
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noUniversalSelectors">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noUniversalSelectors
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.strictPropertyOrder">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>strictPropertyOrder
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.zeroUnits">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>zeroUnits
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recess.Constructor.prototype">module recess.Constructor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.compile">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.constructor">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>constructor
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.log">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>log
            <span class="apidocSignatureSpan">(str, force)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.parse">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.read">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.test">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>test
            <span class="apidocSignatureSpan">(validation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.validate">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.validateStatus">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>validateStatus
            <span class="apidocSignatureSpan">(failed)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recess" id="apidoc.module.recess">module recess</a></h1>


    <h2>
        <a href="#apidoc.element.recess.recess" id="apidoc.element.recess.recess">
        function <span class="apidocSignatureSpan"></span>recess
        <span class="apidocSignatureSpan">(paths, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">recess = function (paths, options, callback) {

  var option, message, i, instances = []

  // if no options default to empty object
  options = options || {}

  // if options is a function, set to callback and set options to {}
  if (typeof options == &#x27;function&#x27;) (callback = options) &#x26;&#x26; (options = {})

  // if single path, convert to array
  if (typeof paths == &#x27;string&#x27;) paths = [paths]

  // there were no paths, show the docs
  if (!paths || !paths.length) return module.exports.docs()

  // if a compress flag is present, we automatically make compile flag true
  options.compress &#x26;&#x26; (options.compile = true)

  // if format is set to compact, automatically set noSummary
  options.format &#x26;&#x26; (options.format == &#x27;compact&#x27;) &#x26;&#x26; (options.noSummary = true)

  // if not compiling, let user know which files will be linted
  if (!options.compile &#x26;&#x26; options.cli &#x26;&#x26; !options.noSummary) {
    message = &#x22;\nAnalyzing the following files: &#x22; + ((paths + &#x27;&#x27;).replace(/,/g, &#x27;, &#x27;) + &#x27;\n&#x27;).grey
    options.stripColors &#x26;&#x26; (message = message.stripColors)
    console.log(message)
  }

  // for each path, create a new RECESS instance
  function recess(init, path, err) {
    if (path = paths.shift()) {
      return instances.push(new RECESS(path, options, recess))
    }

    // map/filter for errors
    err = instances
      .map(function (i) {
        return i.errors.length &#x26;&#x26; i.errors
      })
      .filter(function (i) {
        return i
      })

    // if no error, set explicitly to null
    err = err.length ? err[0] : null

    //callback
    callback &#x26;&#x26; callback(err, instances)
  }

  // start processing paths
  recess(true)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor" id="apidoc.element.recess.Constructor">
        function <span class="apidocSignatureSpan">recess.</span>Constructor
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RECESS(path, options, callback) {
  this.path = path
  this.output = []
  this.errors = []
  this.options = _.extend({}, RECESS.DEFAULTS, options)
  path &#x26;&#x26; this.read()
  this.callback = callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
+ &#x22; ms (&#x22;
+ parseInt(1000 / (end - start) * data.length / 1024)
+ &#x22; KB\/s)&#x22;
      )

      new(less.Parser)({ optimization: 2 }).parse(css, function (err, tree) {

var play = new recess.<span class="apidocCodeKeywordSpan">Constructor</span>(false)

play.data = css
play.definitions = tree.rules
play.path = &#x27;less&#x27;
play.callback = function () {
  end = new Date()
  console.log(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.docs" id="apidoc.element.recess.docs">
        function <span class="apidocSignatureSpan">recess.</span>docs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">docs = function () {
  console.log(&#x22;\nGENERAL USE: &#x22; + &#x22;$&#x22;.grey + &#x22; recess&#x22;.cyan + &#x22; [path] &#x22;.yellow + &#x22;[options]\n&#x22;.grey)
  console.log(&#x22;OPTIONS:&#x22;)
  for (var option in RECESS.DEFAULTS) console.log(&#x27;  --&#x27; + option)
  console.log(&#x22;\nEXAMPLE:\n\n&#x22; + &#x22;  $&#x22;.grey + &#x22; recess&#x22;.cyan + &#x22; ./bootstrap.css &#x22;.yellow + &#x22;--noIDs false\n&#x22;.grey)
  console.log(&#x27;GENERAL HELP: &#x27; + &#x27;http://git.io/recess\n&#x27;.yellow)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , config = &#x27;.recessrc&#x27;
  , writeFile
  , options
  , output
  , paths

// exit with docs
if (process.argv.length == 2) return recess.<span class="apidocCodeKeywordSpan">docs</span>()

// define expected options
options = {
  compile: Boolean
, compress: Boolean
, config: path
, format: String
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recess.Constructor" id="apidoc.module.recess.Constructor">module recess.Constructor</a></h1>


    <h2>
        <a href="#apidoc.element.recess.Constructor.Constructor" id="apidoc.element.recess.Constructor.Constructor">
        function <span class="apidocSignatureSpan">recess.</span>Constructor
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RECESS(path, options, callback) {
  this.path = path
  this.output = []
  this.errors = []
  this.options = _.extend({}, RECESS.DEFAULTS, options)
  path &#x26;&#x26; this.read()
  this.callback = callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
+ &#x22; ms (&#x22;
+ parseInt(1000 / (end - start) * data.length / 1024)
+ &#x22; KB\/s)&#x22;
      )

      new(less.Parser)({ optimization: 2 }).parse(css, function (err, tree) {

var play = new recess.<span class="apidocCodeKeywordSpan">Constructor</span>(false)

play.data = css
play.definitions = tree.rules
play.path = &#x27;less&#x27;
play.callback = function () {
  end = new Date()
  console.log(
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recess.Constructor.RULES" id="apidoc.module.recess.Constructor.RULES">module recess.Constructor.RULES</a></h1>


    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.inlineImages" id="apidoc.element.recess.Constructor.RULES.inlineImages">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>inlineImages
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inlineImages = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no selector to validate
  if (!def.rules) return isValid

  // loop over selectors
  def.rules.forEach(function (rule) {
    var extract
      , line

    // continue to next rule if no url is present
    if ( !(rule.value
        &#x26;&#x26; rule.value.is == &#x27;value&#x27;
        &#x26;&#x26; RULE.exp.test(rule.value.toCSS({}))) ) return

    // calculate line number for the extract
    line = util.getLine(rule.index, data)
    extract = util.padLine(line)

    // highlight invalid 0 units
    extract += rule.toCSS({}).replace(RULE.exp, function ($1) {
      return $1.magenta
    })

    // set invalid flag to false
    isValid = false

    // set error object on defintion token
    util.throwError(def, {
      type: RULE.type
    , message: RULE.message
    , extract: extract
    , line: line
    })

  })

  // return validation state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  RECESS.Constructor.prototype.validate = noop

  Recess.data = fs.readFileSync(path, &#x27;utf8&#x27;)

  Recess.parse()

  Recess.definitions.forEach(function (def) {
RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">inlineImages</span>(def, Recess.data)

if (counts[0]) {
  assert.ok(def.errors)
  assert.equal(def.errors.length, counts.shift(), &#x27;Correct error count found&#x27;)
  def.errors.forEach(function (error) {
    assert.equal(def.errors[0].type, &#x27;inlineImages&#x27;)
    assert.equal(error.line, lines.shift(), &#x27;Correct line number reported&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noIDs" id="apidoc.element.recess.Constructor.RULES.noIDs">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noIDs
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noIDs = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no selectors to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // loop over selector entities
    selector.elements.forEach(function (element) {

      var extract
        , line

      // continue to next element if no js- prefix
      if (!RULE.exp.test(element.value)) return

      // calculate line number for the extract
      line = util.getLine(element.index - element.value.length, data)
      extract = util.padLine(line)

      // highlight invalid styling of ID
      extract += element.value.replace(RULE.exp, &#x27;#&#x27;.magenta)

      // set invalid flag to false
      isValid = false

      // set error object on defintion token
      util.throwError(def, {
        type: RULE.type
      , message: RULE.message
      , extract: extract
      , line: line
      })

    })
  })

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Recess.data = fs.readFileSync(path, &#x27;utf8&#x27;)

Recess.parse()

Recess.definitions.forEach(function (def) {

  RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noIDs</span>(def, Recess.data)

  assert.ok(def.errors)
  assert.equal(def.errors.length, 1, &#x27;one error found&#x27;)
  assert.equal(def.errors[0].type, &#x27;noIDs&#x27;)
  assert.equal(def.errors[0].line, lines.shift(), &#x27;Correct line number reported&#x27;)

})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noJSPrefix" id="apidoc.element.recess.Constructor.RULES.noJSPrefix">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noJSPrefix
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noJSPrefix = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no selector to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // loop over selector entities
    selector.elements.forEach(function (element) {

      var extract
        , line

      // continue to next element if .js- prefix not styled
      if (!RULE.exp.test(element.value)) return

      // calculate line number for the extract
      line = util.getLine(element.index - element.value.length, data)
      extract = util.padLine(line)

      // highlight invalid styling of .js- prefix
      extract += element.value.replace(RULE.exp, &#x27;.js-&#x27;.magenta)

      // set invalid flag to false
      isValid = false

      // set error object on defintion token
      util.throwError(def, {
        type: RULE.type
      , message: RULE.message
      , extract: extract
      , line: line
      })

    })

  })

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  Recess.data = fs.readFileSync(path, &#x27;utf8&#x27;)

  Recess.parse()

  Recess.definitions.forEach(function (def) {

RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noJSPrefix</span>(def, Recess.data)

assert.ok(def.errors)

assert.equal(def.errors.length, 2, &#x27;one error found&#x27;)
assert.equal(def.errors[0].type, &#x27;noJSPrefix&#x27;)
assert.equal(def.errors[0].line, lines.shift(), &#x27;Correct line number reported&#x27;)
assert.equal(def.errors[1].type, &#x27;noJSPrefix&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noOverqualifying" id="apidoc.element.recess.Constructor.RULES.noOverqualifying">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noOverqualifying
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noOverqualifying = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no selector to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // evaluate selector to string and trim whitespace
    var selectorString = selector.toCSS().trim()
      , extract
      , line

    // if selector isn&#x27;t overqualified continue
    if (!RULE.exp.test(selectorString)) return

    // calculate line number for the extract
    line = util.getLine(selector.elements[0].index - selector.elements[0].value.length, data)
    extract = util.padLine(line)

    // highlight selector overqualification
    extract += selectorString.replace(RULE.exp, function ($1) { return $1.magenta })

    // set invalid flag to false
    isValid = false

    // set error object on defintion token
    util.throwError(def, {
      type: RULE.type
    , message: RULE.message
    , extract: extract
    , line: line
    })

  })

  // return validation state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  RECESS.Constructor.prototype.validate = noop

  Recess.data = fs.readFileSync(path, &#x27;utf8&#x27;)

  Recess.parse()

  Recess.definitions.forEach(function (def) {
RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noOverqualifying</span>(def, Recess.data)

assert.ok(def.errors)
assert.equal(def.errors.length, counts.shift(), &#x27;Correct error count found&#x27;)
def.errors.forEach(function (error) {
  assert.equal(error.type, &#x27;noOverqualifying&#x27;)
  assert.equal(error.line, lines.shift(), &#x27;Correct line number reported&#x27;)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noUnderscores" id="apidoc.element.recess.Constructor.RULES.noUnderscores">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noUnderscores
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(def, data) {

  // default validation to true
  var isValid = true

  // return if no selector to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // loop over selector entities
    selector.elements.forEach(function (element) {

      var extract
        , line

      // continue to next element if no underscore
      if (!RULE.exp.test(element.value)) return

      // calculate line number for the extract
      line = util.getLine(element.index - element.value.length, data)
      extract = util.padLine(line)

      // highlight invalid underscores
      extract += element.value.replace(RULE.exp, &#x27;_&#x27;.magenta)

      // set invalid flag to false
      isValid = false

      // set error object on defintion token
      util.throwError(def, {
        type: RULE.type
      , message: RULE.message
      , extract: extract
      , line: line
      })

    })
  })

  // return valid state
  return isValid

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Recess.data = fs.readFileSync(path, &#x27;utf8&#x27;)

Recess.parse()

Recess.definitions.forEach(function (def) {

  RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noUnderscores</span>(def, Recess.data)

  assert.ok(def.errors)
  assert.equal(def.errors.length, 1, &#x27;one error found&#x27;)
  assert.equal(def.errors[0].type, &#x27;noUnderscores&#x27;)
  assert.equal(def.errors[0].line, lines.shift(), &#x27;Correct line number reported&#x27;)

})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noUniversalSelectors" id="apidoc.element.recess.Constructor.RULES.noUniversalSelectors">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noUniversalSelectors
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noUniversalSelectors = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no rules to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // loop over selector entities
    selector.elements.forEach(function (element) {

      var extract
        , line

      // continue to next element if no underscore
      if (!RULE.exp.test(element.value)) return

      // calculate line number for the extract
      line = util.getLine(element.index - element.value.length, data)
      extract = util.padLine(line)

      // highlight the invalid use of a universal selector
      extract += selector.toCSS({}).replace(RULE.exp, &#x27;*&#x27;.magenta)

      // set invalid flag to false
      isValid = false

      // set error object on defintion token
      util.throwError(def, {
        type: RULE.type
      , message: RULE.message
      , extract: extract
      , line: line
      })

    })
  })

  // return valid state
  return isValid

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  Recess.data = fs.readFileSync(path, &#x27;utf8&#x27;)

  Recess.parse()

  Recess.definitions.forEach(function (def) {

RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noUniversalSelectors</span>(def, Recess.data)

assert.ok(def.errors)
assert.equal(def.errors.length, counts.shift(), &#x27;Correct error count found&#x27;)
def.errors.forEach(function (error) {
  assert.equal(error.type, &#x27;noUniversalSelectors&#x27;)
  assert.equal(error.line, lines.shift(), &#x27;Correct line number reported&#x27;)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.strictPropertyOrder" id="apidoc.element.recess.Constructor.RULES.strictPropertyOrder">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>strictPropertyOrder
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">strictPropertyOrder = function (def, data) {

  // // default validation to true
  var isValid = true
    , dict = {}
    , index = 0
    , cleanRules
    , sortedRules
    , firstLine
    , extract
    , selector

  // return if no rules to validate
  if (!def.rules) return isValid

  // recurse over nested rulesets
  def.rules.forEach(function (rule) {
    if (rule.selectors) module.exports(rule, data)
  })

  cleanRules = def.rules.map(function (rule) {
    return rule.name &#x26;&#x26; rule
  }).filter(function (item) { return item })

  // sort rules
  sortedRules = _.sortBy(cleanRules, function (rule) {

    // pad value of each rule position to account for vendor prefixes
    var padding = (vendorPrefixes.length + 1) * 10
      , root
      , val

    // strip vendor prefix and hack prefix from rule name to find root
    root = rule.name
      .replace(VENDOR_PREFIX, &#x27;&#x27;)
      .replace(HACK_PREFIX, &#x27;&#x27;)

    // find value of order of the root css property
    val = order.indexOf(root)

    // if property is not found, exit with property not found error
    if (!~val) {
      return util.throwError(def, {
        type: &#x27;propertyNotFound&#x27;
      , message: &#x27;Unknown property name: &#x22;&#x27; + rule.name + &#x27;&#x22;&#x27;
      })
    }

    // pad value
    val  = (val * padding) + 10

    // adjust value based on prefix
    val += VENDOR_PREFIX.exec(rule.name) ? vendorPrefixes.indexOf(RegExp.$1) : (vendorPrefixes.length + 1)

    // adjust value based on css hack
    val += HACK_PREFIX.exec(rule.name) ? (hackPrefixes.indexOf(RegExp.$1)) : 0

    // return sort value
    return val
  })

  // check to see if sortedRules has same order as provided rules
  isValid = _.isEqual(sortedRules, cleanRules)

  // return if sort is correct
  if (isValid) return isValid

  // get the line number of the first rule
  firstLine = util.getLine(def.rules[0].index, data)

  // generate a extract what the correct sorted rules would look like
  extract = sortedRules.map(function (rule) {
    if (!rule.name) return
    return util.padLine(firstLine + index++)
      + &#x27; &#x27; + rule.name + &#x27;: &#x27;
      + (typeof rule.value == &#x27;string&#x27; ? rule.value : rule.value.toCSS({}))
      + &#x27;;&#x27;
  }).filter(function (item) { return item }).join(&#x27;\n&#x27;)

  // extract selector for error message
  selector = (&#x27; &#x22;&#x27; + def.selectors.map(function (selector) {
    return selector.toCSS &#x26;&#x26; selector.toCSS({}).replace(/^\s/, &#x27;&#x27;)
  }).join(&#x27;, &#x27;) + &#x27;&#x22;&#x27;).magenta

  // set error object on defintion token
  util.throwError(def, {
    type: RULE.type
  , message: RULE.message + selector + &#x27;\n\n  Correct order below:\n&#x27;.grey
  , extract: extract
  , sortedRules: sortedRules
  , line: firstLine
  })

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

RECESS.Constructor.prototype.validate = noop

Recess.data = fs.readFileSync(path, &#x27;utf8&#x27;)

Recess.parse()

RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">strictPropertyOrder</span>(Recess.definitions[0], Recess.data)

assert.ok(Recess.definitions[0].errors)
assert.equal(Recess.definitions[0].errors.length, 1, &#x27;one error found&#x27;)
assert.equal(Recess.definitions[0].errors[0].type, &#x27;strictPropertyOrder&#x27;, &#x27;strictPropertyOrder exception raised&#
x27;)
assert.equal(Recess.definitions[0].errors[0].line, 5, &#x27;Correct line number reported&#x27;)
assert.equal(Recess.definitions[0].errors[0].sortedRules.length, Recess.definitions[0].rules.length, &#x27;same rule length in property
&#x27;)
assert.equal(Recess.definitions[0].errors[0].sortedRules[0].name, &#x27;position&#x27;, &#x27;Correctly ordered&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.zeroUnits" id="apidoc.element.recess.Constructor.RULES.zeroUnits">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>zeroUnits
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeroUnits = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no rules to validate
  if (!def.rules) return isValid

  // loop over rules
  def.rules.forEach(function (rule) {
    var extract
      , line

    // continue to next rule if no 0 units are present
    if ( !(rule.value
        &#x26;&#x26; rule.value.is == &#x27;value&#x27;
        &#x26;&#x26; RULE.exp.test(rule.value.toCSS({}))) ) return

    // calculate line number for the extract
    line = util.getLine(rule.index, data)
    extract = util.padLine(line)

    // highlight invalid 0 units
    extract += rule.toCSS({}).replace(RULE.exp, function ($1) {
      return 0 + $1.slice(1).magenta
    })

    // set invalid flag to false
    isValid = false

    // set error object on defintion token
    util.throwError(def, {
      type: RULE.type
    , message: RULE.message
    , extract: extract
    , line: line
    })

  })

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recess.Constructor.prototype" id="apidoc.module.recess.Constructor.prototype">module recess.Constructor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.compile" id="apidoc.element.recess.Constructor.prototype.compile">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function () {
  var that = this
    , key
    , css

  // activate all relevant compilers
  Object.keys(this.options).forEach(function (key) {
    that.options[key]
      &#x26;&#x26; RECESS.COMPILERS[key]
      &#x26;&#x26; RECESS.COMPILERS[key].on.call(that)
  })

  // iterate over defintions and compress them (join with new lines)
  css = this.definitions.map(function (def) {
    return def.toCSS([[]], { data: that.data, compress: that.options.compress })
  }).join(this.options.compress ? &#x27;&#x27; : &#x27;\n&#x27;)

  // minify with cssmin
  if (that.options.compress) css = require(&#x27;./min&#x27;).compressor.cssmin(css)

  // deactivate all relevant compilers
  Object.keys(this.options).reverse().forEach(function (key) {
    that.options[key]
      &#x26;&#x26; RECESS.COMPILERS[key]
      &#x26;&#x26; RECESS.COMPILERS[key].off()
  })

  // cleanup trailing newlines
  css = css.replace(/[\n\s\r]*$/, &#x27;&#x27;)

  // output css
  this.log(css, true)

  // callback and exit
  this.callback &#x26;&#x26; this.callback()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            + (end - start)
            + &#x22; ms (&#x22;
            + parseInt(1000 / (end - start) * data.length / 1024)
            + &#x22; KB\/s)&#x22;
          )
        }
        start = new Date()
        play.<span class="apidocCodeKeywordSpan">compile</span>()
      })

    })
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.constructor" id="apidoc.element.recess.Constructor.prototype.constructor">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>constructor
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RECESS(path, options, callback) {
  this.path = path
  this.output = []
  this.errors = []
  this.options = _.extend({}, RECESS.DEFAULTS, options)
  path &#x26;&#x26; this.read()
  this.callback = callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.log" id="apidoc.element.recess.Constructor.prototype.log">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>log
        <span class="apidocSignatureSpan">(str, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (str, force) {

  if (this.options.stripColors) str = str.stripColors

  // if compiling only write with force flag
  if (!this.options.compile || force) {
    this.options.cli ? console.log(str) : this.output.push(str)
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x22;name&#x22;: &#x22;jonschlinkert&#x22;,
    &#x22;email&#x22;: &#x22;github@sellside.com&#x22;
  }
],
&#x22;name&#x22;: &#x22;recess&#x22;,
&#x22;optionalDependencies&#x22;: {},
&#x22;preferGlobal&#x22;: true,
&#x22;readme&#x22;: &#x22;RECESS [![Build Status](https://secure.travis-ci.org/twitter/recess.png)](http://travis-ci.org/twitter
/recess)\n======\n\nDeveloped at Twitter to support our internal styleguide, RECESS is a simple, attractive code quality tool for CSS built on top of LESS.\n\nIncorporate it into your development process as a linter, or integrate it directly into your build system as a compiler, RECESS will keep your source looking clean and super manageable.\n\n\nGENERAL USE\n-----------\n\n```CLI\n$ recess [path] [options]\n```\n\nOPTIONS\n-------\n\n- --compile - compiles your code and outputs it to the terminal. Fixes white space and sort order. Can compile css or less.\n- --compress - compress your compiled code.\n- --config - accepts a path, which specifies a json config object\n- --format &#x3c;format&#x3e; - control the output format of errors:\n  - --format text - the default format, shows errors and context\n  - --format compact - show errors one-error-per-line, useful for IDE integration\n- --noSummary - don&#x27;t output the summary block for each file\n- --includePath - accepts an additional directory path to look for `@import`:ed LESS files in.\n- --stripColors - removes color from output (useful when logging)\n- --watch - watch filesystem for changes, useful when compiling Less projects\n- --noIDs - doesn&#x27;t complain about using IDs in your stylesheets\n- --noJSPrefix - doesn&#x27;t complain about styling `.js-` prefixed classnames\n- --noOverqualifying - doesn&#x27;t complain about overqualified selectors (ie: `div#foo.bar`)\n- --noUnderscores - doesn&#x27;t complain about using underscores in your class names\n- --noUniversalSelectors - doesn&#x27;t complain about using the universal `*` selector\n- --prefixWhitespace - adds whitespace prefix to line up vender prefixed properties\n- --strictPropertyOrder - doesn&#x27;t looking into your property ordering\n- --zeroUnits - doesn&#x27;t complain if you add units to values of 0\n\n\nEXAMPLES\n--------\n\nLint all css files\n\n```CLI\n$ recess *.css\n```\n\nLint file, ignore styling of IDs\n\n```CLI\n$ recess ./bootstrap.css --noIds false\n```\n\nLint file with compact output and no color\n\n```CLI\n$ recess ./bootstrap.css --format compact --stripColors\n```\n\nCompile and compress .less file, then output it to a new file\n\n```CLI\n$ recess ./bootstrap.less --compress &#x3e; ./bootstrap-production.css\n```\n\nWatch a directory for changes and auto compile a css file from the changes. *experimental*\n\n```CLI\n$ recess input.less:ouput.css --watch watch/this/dir/for/changes\n```\n\nWatch a single file for changes and auto compile a css file from the changes. *experimental*\n\n```CLI\n$ recess input.less:ouput.css --watch\n```\n\nPROGRAMMATIC API\n----------------\n\nRecess provides a pretty simple programmatic api.\n\n```JS\nvar recess = require(&#x27;recess&#x27;)\n```\n\nOnce you&#x27;ve required recess, just pass it a `path` (or array of paths) and an optional `options` object and an optional `callback`:\n\n```js\nrecess([&#x27;../fat.css&#x27;, &#x27;../twitter.css&#x27;], { compile: true }, callback)\n```\n\nThe following options (and defaults) are available in the programatic api:\n\n- compile: false\n- compress: false\n- includePath: []\n- noIDs: true\n- noJSPrefix: true\n- noOverqualifying: true\n- noUnderscores: true\n- noUniversalSelectors: true\n- prefixWhitespace: true\n- strictPropertyOrder: true\n- stripColors: false\n- zeroUnits: true\n\nThe callback is fired when each instance has finished processessing an input. The callback is passed an array of of instances (one for each path). The instances have a bunch of useful things on them like the raw data and an array of output strings.\n\nWhen compiling, access the compiled source through the output property:\n\n```js\nvar recess = require(&#x27;recess&#x27;)\n\nrecess(&#x27;./js/fat.css&#x27;, { compile: true }, function (err, obj) {\n  if (err) throw err\n  console.<span class="apidocCodeKeywordSpan">log</span>(\n  \tobj // recess instance for fat.css\n  , obj.output // array of loggable content\n  , obj.errors // array of failed lint rules\n  )\n})\n```\n\nINSTALLATION\n------------\n\nTo install recess you need both node and npm installed.\n\n```CLI\n$ npm install recess -g\n```\n\nAUTHORS\n------------\n\n+ **Jacob Thornton**: https://twitter.com/fat\n\nLICENSE\n------------\n\nCopyright 2012 Twitter, Inc.\n\nLicensed under the Apache License, Version 2.0: http://www.apache.org/licenses/LICENSE-2.0&#x22;,
&#x22;readmeFilename&#x22;: &#x22;README.md&#x22;,
&#x22;repository&#x22;: {
  &#x22;type&#x22;: &#x22;git&#x22;,
  &#x22;url&#x22;: &#x22;git://github.com/twitter/recess.git&#x22;
},
&#x22;scripts&#x22;: {
  &#x22;test&#x22;: &#x22;node test&#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.parse" id="apidoc.element.recess.Constructor.prototype.parse">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function () {
  var that = this
    , options = {
        paths: [path.dirname(this.path)].concat(this.options.includePath)
      , optimization: 0
      , filename: this.path &#x26;&#x26; this.path.replace(/.*(?=\/)\//, &#x27;&#x27;)
      }

  // try to parse with less parser
  try {

    // instantiate new parser with options
    new less.Parser(options)

      // parse data into tree
      .parse(this.data, function (err, tree) {

        if (err) {
          // push to errors array
          that.errors.push(err)

          if (err.type == &#x27;Parse&#x27;) {
            // parse error
            that.log(&#x22;Parser error&#x22;.red + (err.filename ? &#x27; in &#x27; + err.filename : &#x27;&#x27;) + &#x27;\n&#x27;)
          } else {
            // other exception
            that.log(String(err.name).red + &#x22;: &#x22; + err.message + &#x27; of &#x27; + String(err.filename).yellow + &#x27;\n&#x27;)
          }

          // if extract - then log it
          err.extract &#x26;&#x26; err.extract.forEach(function (line, index) {
            that.log(util.padLine(err.line + index) + line)
          })

          // add extra line for readability after error log
          that.log(&#x22; &#x22;)

          // exit with callback if present
          return that.callback &#x26;&#x26; that.callback()
        }

        // test to see if file has a less extension
        if (/less$/.test(that.path) &#x26;&#x26; !that.parsed) {

          // if it&#x27;s a LESS file, we flatten it
          that.data = tree.toCSS({})

          // set parse to true so as to not infinitely reparse less files
          that.parsed = true

          // reparse less file
          return that.parse()
        }

        // set definitions to parse tree
        that.definitions = tree.rules

        // validation defintions
        that.options.compile ? that.compile() : that.validate()
      })

  } catch (err) {

    // less exploded trying to parse the file (╯°□°）╯︵ ┻━┻
    // push to errors array
    that.errors.push(err)

    // log a message trying to explain why
    that.log(
        &#x22;Parse error&#x22;.red
      + &#x22;: &#x22;
      + err.message
      + &#x22; on line &#x22;
      + util.getLine(err.index, this.data)
    )

    // exit with callback if present
    this.callback &#x26;&#x26; this.callback()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , less = require(&#x27;less&#x27;)
  , recess = require(&#x27;../lib&#x27;)
  , file = path.join(__dirname, &#x27;benchmark.less&#x27;)

fs.readFile(file, &#x27;utf8&#x27;, function (e, data) {
    var css, start, end

    new(less.Parser)({ optimization: 2 }).<span class="apidocCodeKeywordSpan">parse</span>(data, function (err, tree) {

start = new Date()
css = tree.toCSS()
end = new Date()

console.log(
    &#x22;  LESS toCSS: &#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.read" id="apidoc.element.recess.Constructor.prototype.read">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
  var that = this

  // try to read data from path
  fs.readFile(this.path, &#x27;utf8&#x27;, function (err, data) {

    //  if err, exit with could not read message
    if (err) {
      that.errors.push(err)
      that.log(&#x27;Error reading file: &#x27;.red + String(that.path).grey + &#x27;\n&#x27;, true)
      return that.callback &#x26;&#x26; that.callback()
    }

    // set instance data
    that.data = data

    // parse data
    that.parse()

  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// core class defintion
function RECESS(path, options, callback) {
this.path = path
this.output = []
this.errors = []
this.options = _.extend({}, RECESS.DEFAULTS, options)
path &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">read</span>()
this.callback = callback
}

// instance methods
RECESS.prototype = {

constructor: RECESS
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.test" id="apidoc.element.recess.Constructor.prototype.test">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>test
        <span class="apidocSignatureSpan">(validation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (validation) {
  var l = this.definitions.length
    , i = 0
    , isValid = true
    , rule
    , def
    , j
    , k

  // test each definition against a given validation
  for (; i &#x3c; l; i++) {
    def = this.definitions[i]
    if (!validation(def, this.data)) isValid = false
  }

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
that.log(&#x22; &#x22;)

// exit with callback if present
return that.callback &#x26;&#x26; that.callback()
          }

          // test to see if file has a less extension
          if (/less$/.<span class="apidocCodeKeywordSpan">test</span>(that.path) &#x26;&#x26; !that.parsed) {

// if it&#x27;s a LESS file, we flatten it
that.data = tree.toCSS({})

// set parse to true so as to not infinitely reparse less files
that.parsed = true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.validate" id="apidoc.element.recess.Constructor.prototype.validate">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var failed
    , key

  // iterate over instance options
  for (key in this.options) {

    // if option has a validation, then we test it
    this.options[key]
      &#x26;&#x26; RECESS.RULES[key]
      &#x26;&#x26; !this.test(RECESS.RULES[key])
      &#x26;&#x26; (failed = true)

  }

  // exit with failed flag to validateStatus
  this.validateStatus(failed)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return that.parse()
    }

    // set definitions to parse tree
    that.definitions = tree.rules

    // validation defintions
    that.options.compile ? that.compile() : that.<span class="apidocCodeKeywordSpan">validate</span>()
  })

    } catch (err) {

// less exploded trying to parse the file (╯°□°）╯︵ ┻━┻
// push to errors array
that.errors.push(err)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.validateStatus" id="apidoc.element.recess.Constructor.prototype.validateStatus">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>validateStatus
        <span class="apidocSignatureSpan">(failed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateStatus = function (failed) {
  var that = this
    , fails
    , formatter

  if (failed) {

    // count errors
    fails = util.countErrors(this.definitions)

    if (!this.options.noSummary) {
      // log file overview
      this.log(&#x27;FILE: &#x27; + this.path.cyan)
      this.log(&#x27;STATUS: &#x27; + &#x27;Busted&#x27;.magenta)
      this.log(&#x27;FAILURES: &#x27; + (fails + &#x27; failure&#x27; + (fails &#x3e; 1 ? &#x27;s&#x27; : &#x27;&#x27;)).magenta + &#x27;\n&#x27;)
    }

    if (this.options.format &#x26;&#x26; this.options.format == &#x27;compact&#x27;) {
      formatter = function (err) {
        that.log(that.path + &#x27;:&#x27; + err.line + &#x27;:&#x27; + err.message)
      }
    } else {
      formatter = function (err) {
        that.log(err.message)
        err.extract &#x26;&#x26; that.log(err.extract + &#x27;\n&#x27;)
      }
    }

    // iterate through each definition
    this.definitions.forEach(function (def) {

      // if there&#x27;s an error, log the error and optional err.extract
      def.errors
        &#x26;&#x26; def.errors.length
        &#x26;&#x26; def.errors.forEach(formatter)
    })

  } else {
    // it was a success - let the user know!
    this.log(&#x27;FILE: &#x27; + this.path.cyan)
    this.log(&#x27;STATUS: &#x27; + &#x27;Perfect!\n&#x27;.yellow)
  }

  // callback and exit
  this.callback &#x26;&#x26; this.callback()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x26;&#x26; RECESS.RULES[key]
    &#x26;&#x26; !this.test(RECESS.RULES[key])
    &#x26;&#x26; (failed = true)

}

// exit with failed flag to validateStatus
this.<span class="apidocCodeKeywordSpan">validateStatus</span>(failed)
  }

, test: function (validation) {
var l = this.definitions.length
  , i = 0
  , isValid = true
  , rule
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
