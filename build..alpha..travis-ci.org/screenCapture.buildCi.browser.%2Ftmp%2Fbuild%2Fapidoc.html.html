<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://twitter.github.com/recess">recess (v1.1.9)</a>
</h1>
<h4>A simple, attractive code quality tool for CSS built on top of LESS</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.recess">module recess</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.recess">
            function <span class="apidocSignatureSpan"></span>recess
            <span class="apidocSignatureSpan">(paths, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor">
            function <span class="apidocSignatureSpan">recess.</span>Constructor
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.docs">
            function <span class="apidocSignatureSpan">recess.</span>docs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.</span>Constructor.RULES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.</span>Constructor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.</span>DEFAULTS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recess.Constructor">module recess.Constructor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.Constructor">
            function <span class="apidocSignatureSpan">recess.</span>Constructor
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.Constructor.</span>COMPILERS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.Constructor.</span>DEFAULTS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recess.Constructor.</span>RULES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recess.Constructor.RULES">module recess.Constructor.RULES</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.inlineImages">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>inlineImages
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noIDs">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noIDs
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noJSPrefix">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noJSPrefix
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noOverqualifying">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noOverqualifying
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noUnderscores">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noUnderscores
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.noUniversalSelectors">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noUniversalSelectors
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.strictPropertyOrder">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>strictPropertyOrder
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.RULES.zeroUnits">
            function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>zeroUnits
            <span class="apidocSignatureSpan">(def, data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recess.Constructor.prototype">module recess.Constructor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.compile">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>compile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.constructor">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>constructor
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.log">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>log
            <span class="apidocSignatureSpan">(str, force)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.parse">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.read">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.test">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>test
            <span class="apidocSignatureSpan">(validation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.validate">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>validate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recess.Constructor.prototype.validateStatus">
            function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>validateStatus
            <span class="apidocSignatureSpan">(failed)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recess" id="apidoc.module.recess">module recess</a></h1>


    <h2>
        <a href="#apidoc.element.recess.recess" id="apidoc.element.recess.recess">
        function <span class="apidocSignatureSpan"></span>recess
        <span class="apidocSignatureSpan">(paths, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">recess = function (paths, options, callback) {

  var option, message, i, instances = []

  // if no options default to empty object
  options = options || {}

  // if options is a function, set to callback and set options to {}
  if (typeof options == 'function') (callback = options) &amp;&amp; (options = {})

  // if single path, convert to array
  if (typeof paths == 'string') paths = [paths]

  // there were no paths, show the docs
  if (!paths || !paths.length) return module.exports.docs()

  // if a compress flag is present, we automatically make compile flag true
  options.compress &amp;&amp; (options.compile = true)

  // if format is set to compact, automatically set noSummary
  options.format &amp;&amp; (options.format == 'compact') &amp;&amp; (options.noSummary = true)

  // if not compiling, let user know which files will be linted
  if (!options.compile &amp;&amp; options.cli &amp;&amp; !options.noSummary) {
    message = "\nAnalyzing the following files: " + ((paths + '').replace(/,/g, ', ') + '\n').grey
    options.stripColors &amp;&amp; (message = message.stripColors)
    console.log(message)
  }

  // for each path, create a new RECESS instance
  function recess(init, path, err) {
    if (path = paths.shift()) {
      return instances.push(new RECESS(path, options, recess))
    }

    // map/filter for errors
    err = instances
      .map(function (i) {
        return i.errors.length &amp;&amp; i.errors
      })
      .filter(function (i) {
        return i
      })

    // if no error, set explicitly to null
    err = err.length ? err[0] : null

    //callback
    callback &amp;&amp; callback(err, instances)
  }

  // start processing paths
  recess(true)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor" id="apidoc.element.recess.Constructor">
        function <span class="apidocSignatureSpan">recess.</span>Constructor
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RECESS(path, options, callback) {
  this.path = path
  this.output = []
  this.errors = []
  this.options = _.extend({}, RECESS.DEFAULTS, options)
  path &amp;&amp; this.read()
  this.callback = callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
+ " ms ("
+ parseInt(1000 / (end - start) * data.length / 1024)
+ " KB\/s)"
      )

      new(less.Parser)({ optimization: 2 }).parse(css, function (err, tree) {

var play = new recess.<span class="apidocCodeKeywordSpan">Constructor</span>(false)

play.data = css
play.definitions = tree.rules
play.path = 'less'
play.callback = function () {
  end = new Date()
  console.log(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.docs" id="apidoc.element.recess.docs">
        function <span class="apidocSignatureSpan">recess.</span>docs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">docs = function () {
  console.log("\nGENERAL USE: " + "$".grey + " recess".cyan + " [path] ".yellow + "[options]\n".grey)
  console.log("OPTIONS:")
  for (var option in RECESS.DEFAULTS) console.log('  --' + option)
  console.log("\nEXAMPLE:\n\n" + "  $".grey + " recess".cyan + " ./bootstrap.css ".yellow + "--noIDs false\n".grey)
  console.log('GENERAL HELP: ' + 'http://git.io/recess\n'.yellow)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , config = '.recessrc'
  , writeFile
  , options
  , output
  , paths

// exit with docs
if (process.argv.length == 2) return recess.<span class="apidocCodeKeywordSpan">docs</span>()

// define expected options
options = {
  compile: Boolean
, compress: Boolean
, config: path
, format: String
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recess.Constructor" id="apidoc.module.recess.Constructor">module recess.Constructor</a></h1>


    <h2>
        <a href="#apidoc.element.recess.Constructor.Constructor" id="apidoc.element.recess.Constructor.Constructor">
        function <span class="apidocSignatureSpan">recess.</span>Constructor
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RECESS(path, options, callback) {
  this.path = path
  this.output = []
  this.errors = []
  this.options = _.extend({}, RECESS.DEFAULTS, options)
  path &amp;&amp; this.read()
  this.callback = callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
+ " ms ("
+ parseInt(1000 / (end - start) * data.length / 1024)
+ " KB\/s)"
      )

      new(less.Parser)({ optimization: 2 }).parse(css, function (err, tree) {

var play = new recess.<span class="apidocCodeKeywordSpan">Constructor</span>(false)

play.data = css
play.definitions = tree.rules
play.path = 'less'
play.callback = function () {
  end = new Date()
  console.log(
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recess.Constructor.RULES" id="apidoc.module.recess.Constructor.RULES">module recess.Constructor.RULES</a></h1>


    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.inlineImages" id="apidoc.element.recess.Constructor.RULES.inlineImages">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>inlineImages
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inlineImages = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no selector to validate
  if (!def.rules) return isValid

  // loop over selectors
  def.rules.forEach(function (rule) {
    var extract
      , line

    // continue to next rule if no url is present
    if ( !(rule.value
        &amp;&amp; rule.value.is == 'value'
        &amp;&amp; RULE.exp.test(rule.value.toCSS({}))) ) return

    // calculate line number for the extract
    line = util.getLine(rule.index, data)
    extract = util.padLine(line)

    // highlight invalid 0 units
    extract += rule.toCSS({}).replace(RULE.exp, function ($1) {
      return $1.magenta
    })

    // set invalid flag to false
    isValid = false

    // set error object on defintion token
    util.throwError(def, {
      type: RULE.type
    , message: RULE.message
    , extract: extract
    , line: line
    })

  })

  // return validation state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  RECESS.Constructor.prototype.validate = noop

  Recess.data = fs.readFileSync(path, 'utf8')

  Recess.parse()

  Recess.definitions.forEach(function (def) {
RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">inlineImages</span>(def, Recess.data)

if (counts[0]) {
  assert.ok(def.errors)
  assert.equal(def.errors.length, counts.shift(), 'Correct error count found')
  def.errors.forEach(function (error) {
    assert.equal(def.errors[0].type, 'inlineImages')
    assert.equal(error.line, lines.shift(), 'Correct line number reported')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noIDs" id="apidoc.element.recess.Constructor.RULES.noIDs">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noIDs
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noIDs = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no selectors to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // loop over selector entities
    selector.elements.forEach(function (element) {

      var extract
        , line

      // continue to next element if no js- prefix
      if (!RULE.exp.test(element.value)) return

      // calculate line number for the extract
      line = util.getLine(element.index - element.value.length, data)
      extract = util.padLine(line)

      // highlight invalid styling of ID
      extract += element.value.replace(RULE.exp, '#'.magenta)

      // set invalid flag to false
      isValid = false

      // set error object on defintion token
      util.throwError(def, {
        type: RULE.type
      , message: RULE.message
      , extract: extract
      , line: line
      })

    })
  })

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Recess.data = fs.readFileSync(path, 'utf8')

Recess.parse()

Recess.definitions.forEach(function (def) {

  RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noIDs</span>(def, Recess.data)

  assert.ok(def.errors)
  assert.equal(def.errors.length, 1, 'one error found')
  assert.equal(def.errors[0].type, 'noIDs')
  assert.equal(def.errors[0].line, lines.shift(), 'Correct line number reported')

})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noJSPrefix" id="apidoc.element.recess.Constructor.RULES.noJSPrefix">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noJSPrefix
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noJSPrefix = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no selector to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // loop over selector entities
    selector.elements.forEach(function (element) {

      var extract
        , line

      // continue to next element if .js- prefix not styled
      if (!RULE.exp.test(element.value)) return

      // calculate line number for the extract
      line = util.getLine(element.index - element.value.length, data)
      extract = util.padLine(line)

      // highlight invalid styling of .js- prefix
      extract += element.value.replace(RULE.exp, '.js-'.magenta)

      // set invalid flag to false
      isValid = false

      // set error object on defintion token
      util.throwError(def, {
        type: RULE.type
      , message: RULE.message
      , extract: extract
      , line: line
      })

    })

  })

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  Recess.data = fs.readFileSync(path, 'utf8')

  Recess.parse()

  Recess.definitions.forEach(function (def) {

RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noJSPrefix</span>(def, Recess.data)

assert.ok(def.errors)

assert.equal(def.errors.length, 2, 'one error found')
assert.equal(def.errors[0].type, 'noJSPrefix')
assert.equal(def.errors[0].line, lines.shift(), 'Correct line number reported')
assert.equal(def.errors[1].type, 'noJSPrefix')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noOverqualifying" id="apidoc.element.recess.Constructor.RULES.noOverqualifying">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noOverqualifying
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noOverqualifying = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no selector to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // evaluate selector to string and trim whitespace
    var selectorString = selector.toCSS().trim()
      , extract
      , line

    // if selector isn't overqualified continue
    if (!RULE.exp.test(selectorString)) return

    // calculate line number for the extract
    line = util.getLine(selector.elements[0].index - selector.elements[0].value.length, data)
    extract = util.padLine(line)

    // highlight selector overqualification
    extract += selectorString.replace(RULE.exp, function ($1) { return $1.magenta })

    // set invalid flag to false
    isValid = false

    // set error object on defintion token
    util.throwError(def, {
      type: RULE.type
    , message: RULE.message
    , extract: extract
    , line: line
    })

  })

  // return validation state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  RECESS.Constructor.prototype.validate = noop

  Recess.data = fs.readFileSync(path, 'utf8')

  Recess.parse()

  Recess.definitions.forEach(function (def) {
RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noOverqualifying</span>(def, Recess.data)

assert.ok(def.errors)
assert.equal(def.errors.length, counts.shift(), 'Correct error count found')
def.errors.forEach(function (error) {
  assert.equal(error.type, 'noOverqualifying')
  assert.equal(error.line, lines.shift(), 'Correct line number reported')
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noUnderscores" id="apidoc.element.recess.Constructor.RULES.noUnderscores">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noUnderscores
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(def, data) {

  // default validation to true
  var isValid = true

  // return if no selector to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // loop over selector entities
    selector.elements.forEach(function (element) {

      var extract
        , line

      // continue to next element if no underscore
      if (!RULE.exp.test(element.value)) return

      // calculate line number for the extract
      line = util.getLine(element.index - element.value.length, data)
      extract = util.padLine(line)

      // highlight invalid underscores
      extract += element.value.replace(RULE.exp, '_'.magenta)

      // set invalid flag to false
      isValid = false

      // set error object on defintion token
      util.throwError(def, {
        type: RULE.type
      , message: RULE.message
      , extract: extract
      , line: line
      })

    })
  })

  // return valid state
  return isValid

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Recess.data = fs.readFileSync(path, 'utf8')

Recess.parse()

Recess.definitions.forEach(function (def) {

  RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noUnderscores</span>(def, Recess.data)

  assert.ok(def.errors)
  assert.equal(def.errors.length, 1, 'one error found')
  assert.equal(def.errors[0].type, 'noUnderscores')
  assert.equal(def.errors[0].line, lines.shift(), 'Correct line number reported')

})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.noUniversalSelectors" id="apidoc.element.recess.Constructor.RULES.noUniversalSelectors">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>noUniversalSelectors
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noUniversalSelectors = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no rules to validate
  if (!def.selectors) return isValid

  // loop over selectors
  def.selectors.forEach(function (selector) {

    // loop over selector entities
    selector.elements.forEach(function (element) {

      var extract
        , line

      // continue to next element if no underscore
      if (!RULE.exp.test(element.value)) return

      // calculate line number for the extract
      line = util.getLine(element.index - element.value.length, data)
      extract = util.padLine(line)

      // highlight the invalid use of a universal selector
      extract += selector.toCSS({}).replace(RULE.exp, '*'.magenta)

      // set invalid flag to false
      isValid = false

      // set error object on defintion token
      util.throwError(def, {
        type: RULE.type
      , message: RULE.message
      , extract: extract
      , line: line
      })

    })
  })

  // return valid state
  return isValid

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  Recess.data = fs.readFileSync(path, 'utf8')

  Recess.parse()

  Recess.definitions.forEach(function (def) {

RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">noUniversalSelectors</span>(def, Recess.data)

assert.ok(def.errors)
assert.equal(def.errors.length, counts.shift(), 'Correct error count found')
def.errors.forEach(function (error) {
  assert.equal(error.type, 'noUniversalSelectors')
  assert.equal(error.line, lines.shift(), 'Correct line number reported')
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.strictPropertyOrder" id="apidoc.element.recess.Constructor.RULES.strictPropertyOrder">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>strictPropertyOrder
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">strictPropertyOrder = function (def, data) {

  // // default validation to true
  var isValid = true
    , dict = {}
    , index = 0
    , cleanRules
    , sortedRules
    , firstLine
    , extract
    , selector

  // return if no rules to validate
  if (!def.rules) return isValid

  // recurse over nested rulesets
  def.rules.forEach(function (rule) {
    if (rule.selectors) module.exports(rule, data)
  })

  cleanRules = def.rules.map(function (rule) {
    return rule.name &amp;&amp; rule
  }).filter(function (item) { return item })

  // sort rules
  sortedRules = _.sortBy(cleanRules, function (rule) {

    // pad value of each rule position to account for vendor prefixes
    var padding = (vendorPrefixes.length + 1) * 10
      , root
      , val

    // strip vendor prefix and hack prefix from rule name to find root
    root = rule.name
      .replace(VENDOR_PREFIX, '')
      .replace(HACK_PREFIX, '')

    // find value of order of the root css property
    val = order.indexOf(root)

    // if property is not found, exit with property not found error
    if (!~val) {
      return util.throwError(def, {
        type: 'propertyNotFound'
      , message: 'Unknown property name: "' + rule.name + '"'
      })
    }

    // pad value
    val  = (val * padding) + 10

    // adjust value based on prefix
    val += VENDOR_PREFIX.exec(rule.name) ? vendorPrefixes.indexOf(RegExp.$1) : (vendorPrefixes.length + 1)

    // adjust value based on css hack
    val += HACK_PREFIX.exec(rule.name) ? (hackPrefixes.indexOf(RegExp.$1)) : 0

    // return sort value
    return val
  })

  // check to see if sortedRules has same order as provided rules
  isValid = _.isEqual(sortedRules, cleanRules)

  // return if sort is correct
  if (isValid) return isValid

  // get the line number of the first rule
  firstLine = util.getLine(def.rules[0].index, data)

  // generate a extract what the correct sorted rules would look like
  extract = sortedRules.map(function (rule) {
    if (!rule.name) return
    return util.padLine(firstLine + index++)
      + ' ' + rule.name + ': '
      + (typeof rule.value == 'string' ? rule.value : rule.value.toCSS({}))
      + ';'
  }).filter(function (item) { return item }).join('\n')

  // extract selector for error message
  selector = (' "' + def.selectors.map(function (selector) {
    return selector.toCSS &amp;&amp; selector.toCSS({}).replace(/^\s/, '')
  }).join(', ') + '"').magenta

  // set error object on defintion token
  util.throwError(def, {
    type: RULE.type
  , message: RULE.message + selector + '\n\n  Correct order below:\n'.grey
  , extract: extract
  , sortedRules: sortedRules
  , line: firstLine
  })

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

RECESS.Constructor.prototype.validate = noop

Recess.data = fs.readFileSync(path, 'utf8')

Recess.parse()

RECESS.Constructor.RULES.<span class="apidocCodeKeywordSpan">strictPropertyOrder</span>(Recess.definitions[0], Recess.data)

assert.ok(Recess.definitions[0].errors)
assert.equal(Recess.definitions[0].errors.length, 1, 'one error found')
assert.equal(Recess.definitions[0].errors[0].type, 'strictPropertyOrder', 'strictPropertyOrder exception raised&amp;#
x27;)
assert.equal(Recess.definitions[0].errors[0].line, 5, 'Correct line number reported')
assert.equal(Recess.definitions[0].errors[0].sortedRules.length, Recess.definitions[0].rules.length, 'same rule length in property
')
assert.equal(Recess.definitions[0].errors[0].sortedRules[0].name, 'position', 'Correctly ordered')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.RULES.zeroUnits" id="apidoc.element.recess.Constructor.RULES.zeroUnits">
        function <span class="apidocSignatureSpan">recess.Constructor.RULES.</span>zeroUnits
        <span class="apidocSignatureSpan">(def, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeroUnits = function (def, data) {

  // default validation to true
  var isValid = true

  // return if no rules to validate
  if (!def.rules) return isValid

  // loop over rules
  def.rules.forEach(function (rule) {
    var extract
      , line

    // continue to next rule if no 0 units are present
    if ( !(rule.value
        &amp;&amp; rule.value.is == 'value'
        &amp;&amp; RULE.exp.test(rule.value.toCSS({}))) ) return

    // calculate line number for the extract
    line = util.getLine(rule.index, data)
    extract = util.padLine(line)

    // highlight invalid 0 units
    extract += rule.toCSS({}).replace(RULE.exp, function ($1) {
      return 0 + $1.slice(1).magenta
    })

    // set invalid flag to false
    isValid = false

    // set error object on defintion token
    util.throwError(def, {
      type: RULE.type
    , message: RULE.message
    , extract: extract
    , line: line
    })

  })

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recess.Constructor.prototype" id="apidoc.module.recess.Constructor.prototype">module recess.Constructor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.compile" id="apidoc.element.recess.Constructor.prototype.compile">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>compile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function () {
  var that = this
    , key
    , css

  // activate all relevant compilers
  Object.keys(this.options).forEach(function (key) {
    that.options[key]
      &amp;&amp; RECESS.COMPILERS[key]
      &amp;&amp; RECESS.COMPILERS[key].on.call(that)
  })

  // iterate over defintions and compress them (join with new lines)
  css = this.definitions.map(function (def) {
    return def.toCSS([[]], { data: that.data, compress: that.options.compress })
  }).join(this.options.compress ? '' : '\n')

  // minify with cssmin
  if (that.options.compress) css = require('./min').compressor.cssmin(css)

  // deactivate all relevant compilers
  Object.keys(this.options).reverse().forEach(function (key) {
    that.options[key]
      &amp;&amp; RECESS.COMPILERS[key]
      &amp;&amp; RECESS.COMPILERS[key].off()
  })

  // cleanup trailing newlines
  css = css.replace(/[\n\s\r]*$/, '')

  // output css
  this.log(css, true)

  // callback and exit
  this.callback &amp;&amp; this.callback()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            + (end - start)
            + " ms ("
            + parseInt(1000 / (end - start) * data.length / 1024)
            + " KB\/s)"
          )
        }
        start = new Date()
        play.<span class="apidocCodeKeywordSpan">compile</span>()
      })

    })
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.constructor" id="apidoc.element.recess.Constructor.prototype.constructor">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>constructor
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RECESS(path, options, callback) {
  this.path = path
  this.output = []
  this.errors = []
  this.options = _.extend({}, RECESS.DEFAULTS, options)
  path &amp;&amp; this.read()
  this.callback = callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.log" id="apidoc.element.recess.Constructor.prototype.log">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>log
        <span class="apidocSignatureSpan">(str, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (str, force) {

  if (this.options.stripColors) str = str.stripColors

  // if compiling only write with force flag
  if (!this.options.compile || force) {
    this.options.cli ? console.log(str) : this.output.push(str)
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    "name": "jonschlinkert",
    "email": "github@sellside.com"
  }
],
"name": "recess",
"optionalDependencies": {},
"preferGlobal": true,
"readme": "RECESS [![Build Status](https://secure.travis-ci.org/twitter/recess.png)](http://travis-ci.org/twitter
/recess)\n======\n\nDeveloped at Twitter to support our internal styleguide, RECESS is a simple, attractive code quality tool for CSS built on top of LESS.\n\nIncorporate it into your development process as a linter, or integrate it directly into your build system as a compiler, RECESS will keep your source looking clean and super manageable.\n\n\nGENERAL USE\n-----------\n\n```CLI\n$ recess [path] [options]\n```\n\nOPTIONS\n-------\n\n- --compile - compiles your code and outputs it to the terminal. Fixes white space and sort order. Can compile css or less.\n- --compress - compress your compiled code.\n- --config - accepts a path, which specifies a json config object\n- --format &lt;format&gt; - control the output format of errors:\n  - --format text - the default format, shows errors and context\n  - --format compact - show errors one-error-per-line, useful for IDE integration\n- --noSummary - don't output the summary block for each file\n- --includePath - accepts an additional directory path to look for `@import`:ed LESS files in.\n- --stripColors - removes color from output (useful when logging)\n- --watch - watch filesystem for changes, useful when compiling Less projects\n- --noIDs - doesn't complain about using IDs in your stylesheets\n- --noJSPrefix - doesn't complain about styling `.js-` prefixed classnames\n- --noOverqualifying - doesn't complain about overqualified selectors (ie: `div#foo.bar`)\n- --noUnderscores - doesn't complain about using underscores in your class names\n- --noUniversalSelectors - doesn't complain about using the universal `*` selector\n- --prefixWhitespace - adds whitespace prefix to line up vender prefixed properties\n- --strictPropertyOrder - doesn't looking into your property ordering\n- --zeroUnits - doesn't complain if you add units to values of 0\n\n\nEXAMPLES\n--------\n\nLint all css files\n\n```CLI\n$ recess *.css\n```\n\nLint file, ignore styling of IDs\n\n```CLI\n$ recess ./bootstrap.css --noIds false\n```\n\nLint file with compact output and no color\n\n```CLI\n$ recess ./bootstrap.css --format compact --stripColors\n```\n\nCompile and compress .less file, then output it to a new file\n\n```CLI\n$ recess ./bootstrap.less --compress &gt; ./bootstrap-production.css\n```\n\nWatch a directory for changes and auto compile a css file from the changes. *experimental*\n\n```CLI\n$ recess input.less:ouput.css --watch watch/this/dir/for/changes\n```\n\nWatch a single file for changes and auto compile a css file from the changes. *experimental*\n\n```CLI\n$ recess input.less:ouput.css --watch\n```\n\nPROGRAMMATIC API\n----------------\n\nRecess provides a pretty simple programmatic api.\n\n```JS\nvar recess = require('recess')\n```\n\nOnce you've required recess, just pass it a `path` (or array of paths) and an optional `options` object and an optional `callback`:\n\n```js\nrecess(['../fat.css', '../twitter.css'], { compile: true }, callback)\n```\n\nThe following options (and defaults) are available in the programatic api:\n\n- compile: false\n- compress: false\n- includePath: []\n- noIDs: true\n- noJSPrefix: true\n- noOverqualifying: true\n- noUnderscores: true\n- noUniversalSelectors: true\n- prefixWhitespace: true\n- strictPropertyOrder: true\n- stripColors: false\n- zeroUnits: true\n\nThe callback is fired when each instance has finished processessing an input. The callback is passed an array of of instances (one for each path). The instances have a bunch of useful things on them like the raw data and an array of output strings.\n\nWhen compiling, access the compiled source through the output property:\n\n```js\nvar recess = require('recess')\n\nrecess('./js/fat.css', { compile: true }, function (err, obj) {\n  if (err) throw err\n  console.<span class="apidocCodeKeywordSpan">log</span>(\n  \tobj // recess instance for fat.css\n  , obj.output // array of loggable content\n  , obj.errors // array of failed lint rules\n  )\n})\n```\n\nINSTALLATION\n------------\n\nTo install recess you need both node and npm installed.\n\n```CLI\n$ npm install recess -g\n```\n\nAUTHORS\n------------\n\n+ **Jacob Thornton**: https://twitter.com/fat\n\nLICENSE\n------------\n\nCopyright 2012 Twitter, Inc.\n\nLicensed under the Apache License, Version 2.0: http://www.apache.org/licenses/LICENSE-2.0",
"readmeFilename": "README.md",
"repository": {
  "type": "git",
  "url": "git://github.com/twitter/recess.git"
},
"scripts": {
  "test": "node test"
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.parse" id="apidoc.element.recess.Constructor.prototype.parse">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function () {
  var that = this
    , options = {
        paths: [path.dirname(this.path)].concat(this.options.includePath)
      , optimization: 0
      , filename: this.path &amp;&amp; this.path.replace(/.*(?=\/)\//, '')
      }

  // try to parse with less parser
  try {

    // instantiate new parser with options
    new less.Parser(options)

      // parse data into tree
      .parse(this.data, function (err, tree) {

        if (err) {
          // push to errors array
          that.errors.push(err)

          if (err.type == 'Parse') {
            // parse error
            that.log("Parser error".red + (err.filename ? ' in ' + err.filename : '') + '\n')
          } else {
            // other exception
            that.log(String(err.name).red + ": " + err.message + ' of ' + String(err.filename).yellow + '\n')
          }

          // if extract - then log it
          err.extract &amp;&amp; err.extract.forEach(function (line, index) {
            that.log(util.padLine(err.line + index) + line)
          })

          // add extra line for readability after error log
          that.log(" ")

          // exit with callback if present
          return that.callback &amp;&amp; that.callback()
        }

        // test to see if file has a less extension
        if (/less$/.test(that.path) &amp;&amp; !that.parsed) {

          // if it's a LESS file, we flatten it
          that.data = tree.toCSS({})

          // set parse to true so as to not infinitely reparse less files
          that.parsed = true

          // reparse less file
          return that.parse()
        }

        // set definitions to parse tree
        that.definitions = tree.rules

        // validation defintions
        that.options.compile ? that.compile() : that.validate()
      })

  } catch (err) {

    // less exploded trying to parse the file (â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»
    // push to errors array
    that.errors.push(err)

    // log a message trying to explain why
    that.log(
        "Parse error".red
      + ": "
      + err.message
      + " on line "
      + util.getLine(err.index, this.data)
    )

    // exit with callback if present
    this.callback &amp;&amp; this.callback()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , less = require('less')
  , recess = require('../lib')
  , file = path.join(__dirname, 'benchmark.less')

fs.readFile(file, 'utf8', function (e, data) {
    var css, start, end

    new(less.Parser)({ optimization: 2 }).<span class="apidocCodeKeywordSpan">parse</span>(data, function (err, tree) {

start = new Date()
css = tree.toCSS()
end = new Date()

console.log(
    "  LESS toCSS: "
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.read" id="apidoc.element.recess.Constructor.prototype.read">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
  var that = this

  // try to read data from path
  fs.readFile(this.path, 'utf8', function (err, data) {

    //  if err, exit with could not read message
    if (err) {
      that.errors.push(err)
      that.log('Error reading file: '.red + String(that.path).grey + '\n', true)
      return that.callback &amp;&amp; that.callback()
    }

    // set instance data
    that.data = data

    // parse data
    that.parse()

  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// core class defintion
function RECESS(path, options, callback) {
this.path = path
this.output = []
this.errors = []
this.options = _.extend({}, RECESS.DEFAULTS, options)
path &amp;&amp; this.<span class="apidocCodeKeywordSpan">read</span>()
this.callback = callback
}

// instance methods
RECESS.prototype = {

constructor: RECESS
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.test" id="apidoc.element.recess.Constructor.prototype.test">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>test
        <span class="apidocSignatureSpan">(validation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">test = function (validation) {
  var l = this.definitions.length
    , i = 0
    , isValid = true
    , rule
    , def
    , j
    , k

  // test each definition against a given validation
  for (; i &lt; l; i++) {
    def = this.definitions[i]
    if (!validation(def, this.data)) isValid = false
  }

  // return valid state
  return isValid
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
that.log(" ")

// exit with callback if present
return that.callback &amp;&amp; that.callback()
          }

          // test to see if file has a less extension
          if (/less$/.<span class="apidocCodeKeywordSpan">test</span>(that.path) &amp;&amp; !that.parsed) {

// if it's a LESS file, we flatten it
that.data = tree.toCSS({})

// set parse to true so as to not infinitely reparse less files
that.parsed = true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.validate" id="apidoc.element.recess.Constructor.prototype.validate">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>validate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function () {
  var failed
    , key

  // iterate over instance options
  for (key in this.options) {

    // if option has a validation, then we test it
    this.options[key]
      &amp;&amp; RECESS.RULES[key]
      &amp;&amp; !this.test(RECESS.RULES[key])
      &amp;&amp; (failed = true)

  }

  // exit with failed flag to validateStatus
  this.validateStatus(failed)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return that.parse()
    }

    // set definitions to parse tree
    that.definitions = tree.rules

    // validation defintions
    that.options.compile ? that.compile() : that.<span class="apidocCodeKeywordSpan">validate</span>()
  })

    } catch (err) {

// less exploded trying to parse the file (â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»
// push to errors array
that.errors.push(err)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recess.Constructor.prototype.validateStatus" id="apidoc.element.recess.Constructor.prototype.validateStatus">
        function <span class="apidocSignatureSpan">recess.Constructor.prototype.</span>validateStatus
        <span class="apidocSignatureSpan">(failed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateStatus = function (failed) {
  var that = this
    , fails
    , formatter

  if (failed) {

    // count errors
    fails = util.countErrors(this.definitions)

    if (!this.options.noSummary) {
      // log file overview
      this.log('FILE: ' + this.path.cyan)
      this.log('STATUS: ' + 'Busted'.magenta)
      this.log('FAILURES: ' + (fails + ' failure' + (fails &gt; 1 ? 's' : '')).magenta + '\n')
    }

    if (this.options.format &amp;&amp; this.options.format == 'compact') {
      formatter = function (err) {
        that.log(that.path + ':' + err.line + ':' + err.message)
      }
    } else {
      formatter = function (err) {
        that.log(err.message)
        err.extract &amp;&amp; that.log(err.extract + '\n')
      }
    }

    // iterate through each definition
    this.definitions.forEach(function (def) {

      // if there's an error, log the error and optional err.extract
      def.errors
        &amp;&amp; def.errors.length
        &amp;&amp; def.errors.forEach(formatter)
    })

  } else {
    // it was a success - let the user know!
    this.log('FILE: ' + this.path.cyan)
    this.log('STATUS: ' + 'Perfect!\n'.yellow)
  }

  // callback and exit
  this.callback &amp;&amp; this.callback()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &amp;&amp; RECESS.RULES[key]
    &amp;&amp; !this.test(RECESS.RULES[key])
    &amp;&amp; (failed = true)

}

// exit with failed flag to validateStatus
this.<span class="apidocCodeKeywordSpan">validateStatus</span>(failed)
  }

, test: function (validation) {
var l = this.definitions.length
  , i = 0
  , isValid = true
  , rule
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>